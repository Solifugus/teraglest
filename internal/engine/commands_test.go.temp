package engine

import (
	"testing"
	"time"

	"teraglest/internal/data"
)

func TestUnitCommand_Creation(t *testing.T) {
	target := Vector3{X: 10, Y: 0, Z: 15}
	command := UnitCommand{
		Type:      CommandMove,
		Target:    &target,
		Priority:  1,
		CreatedAt: time.Now(),
	}

	if command.Type != CommandMove {
		t.Errorf("Expected command type Move, got %v", command.Type)
	}

	if command.Priority != 1 {
		t.Errorf("Expected priority 1, got %v", command.Priority)
	}

	if command.Target.X != 10 {
		t.Errorf("Expected target X=10, got %.1f", command.Target.X)
	}
}

func TestCommandType_String(t *testing.T) {
	tests := []struct {
		cmdType  CommandType
		expected string
	}{
		{CommandMove, "Move"},
		{CommandAttack, "Attack"},
		{CommandGather, "Gather"},
		{CommandBuild, "Build"},
		{CommandRepair, "Repair"},
		{CommandStop, "Stop"},
		{CommandHold, "Hold"},
		{CommandPatrol, "Patrol"},
		{CommandFollow, "Follow"},
		{CommandGuard, "Guard"},
		{CommandProduce, "Produce"},
		{CommandUpgrade, "Upgrade"},
	}

	for _, test := range tests {
		result := test.cmdType.String()
		if result != test.expected {
			t.Errorf("Expected %s, got %s", test.expected, result)
		}
	}
}

func TestCommandPriority(t *testing.T) {
	command := UnitCommand{
		Type:     CommandMove,
		Priority: 2, // High priority
	}

	if command.Priority != 2 {
		t.Errorf("Expected priority 2, got %d", command.Priority)
	}
}

func TestCommandProcessor_Creation(t *testing.T) {
	// Create test world
	world := &World{
		Width:  100,
		Height: 100,
	}

	processor := NewCommandProcessor(world)

	if processor == nil {
		t.Error("CommandProcessor should not be nil")
	}

	if processor.world != world {
		t.Error("CommandProcessor world reference not set correctly")
	}
}

func TestCommandProcessor_IssueCommand(t *testing.T) {
	// Create test environment using proper API
	settings := GameSettings{PlayerFactions: map[int]string{1: "test"}}
	techTree := &data.TechTree{}
	assetMgr := &data.AssetManager{}

	world, err := NewWorld(settings, techTree, assetMgr)
	if err != nil {
		t.Fatalf("Failed to create world: %v", err)
	}

	processor := NewCommandProcessor(world)

	// Create test unit using proper UnitManager with minimal unit def
	unitDef := &data.UnitDefinition{
		Name: "Test Warrior",
	}

	unit, err := world.ObjectManager.CreateUnit(1, "warrior", Vector3{X: 0, Y: 0, Z: 0}, unitDef)
	if err != nil {
		t.Fatalf("Failed to create unit: %v", err)
	}

	// Test move command
	moveCmd := CreateMoveCommand(Vector3{X: 10, Y: 0, Z: 10}, false)
	err = processor.IssueCommand(unit.GetID(), moveCmd)
	if err != nil {
		t.Fatalf("Failed to issue move command: %v", err)
	}

	if len(unit.CommandQueue) != 0 { // Command should be current, not queued
		t.Errorf("Expected 0 commands in queue (should be current), got %d", len(unit.CommandQueue))
	}

	if unit.CurrentCommand == nil || unit.CurrentCommand.Type != CommandMove {
		t.Error("Expected current command to be Move")
	}

	// Test invalid unit ID
	err = processor.IssueCommand(999, moveCmd)
	if err == nil {
		t.Error("Expected error for invalid unit ID")
	}
}

func TestCommandProcessor_ProcessCommands(t *testing.T) {
	// Create test environment
	world := &World{
		Width:  100,
		Height: 100,
	}
	processor := NewCommandProcessor(world)
	// Use proper world creation
	settings := GameSettings{PlayerFactions: map[int]string{1: "test"}}
	techTree := &data.TechTree{}
	assetMgr := &data.AssetManager{}

	world, err := NewWorld(settings, techTree, assetMgr)
	if err != nil {
		t.Fatalf("Failed to create world: %v", err)
	}
	processor = NewCommandProcessor(world)

	// Create test unit properly with minimal unit def
	unitDef := &data.UnitDefinition{
		Name: "Test Unit",
	}

	unit, err := world.ObjectManager.CreateUnit(1, "test_unit", Vector3{X: 0, Y: 0, Z: 0}, unitDef)
	if err != nil {
		t.Fatalf("Failed to create unit: %v", err)
	}

	// Issue move command
	moveCmd := CreateMoveCommand(Vector3{X: 10, Y: 0, Z: 0}, false)
	err = processor.IssueCommand(unit.GetID(), moveCmd)
	if err != nil {
		t.Fatalf("Failed to issue command: %v", err)
	}

	// Process command directly
	deltaTime := 100 * time.Millisecond
	if unit.CurrentCommand != nil {
		processor.ProcessCommand(unit, unit.CurrentCommand, deltaTime)
	}

	// Unit should be moving
	if unit.State != UnitStateMoving {
		t.Errorf("Expected unit to be moving, got state %v", unit.State)
	}

	// Unit should reach destination
	if unit.Position.X != 10 {
		t.Errorf("Expected unit to reach X=10, got %.1f", unit.Position.X)
	}

	// Command should be completed and removed
	if len(unit.CommandQueue) != 0 {
		t.Errorf("Expected command queue to be empty, got %d commands", len(unit.CommandQueue))
	}
}

func TestCommandProcessor_AttackCommand(t *testing.T) {
	// Create test environment
	world := &World{
		Width:  100,
		Height: 100,
	}
	processor := NewCommandProcessor(world)
	objectMgr := NewObjectManager()

	// Create attacker
	attacker := &GameUnit{
		ID:           1,
		Position:     Vector3{X: 0, Y: 0, Z: 0},
		AttackRange:  5.0,
		AttackDamage: 25,
		AttackSpeed:  time.Second,
		State:        UnitStateIdle,
		CommandQueue: make([]UnitCommand, 0),
	}

	// Create target
	target := &GameUnit{
		ID:        2,
		Position:  Vector3{X: 3, Y: 0, Z: 0},
		Health:    100,
		MaxHealth: 100,
		State:     UnitStateIdle,
	}

	objectMgr.AddUnit(attacker)
	objectMgr.AddUnit(target)
	world.ObjectManager = objectMgr

	// Issue attack command
	attackCmd := CreateAttackCommand(2)
	err := processor.IssueCommand(1, attackCmd)
	if err != nil {
		t.Fatalf("Failed to issue attack command: %v", err)
	}

	// Process command
	processor.ProcessCommands(time.Second)

	// Target should take damage
	if target.GetHealth() >= 100 {
		t.Error("Target should have taken damage")
	}

	// Attacker should be attacking
	if attacker.State != UnitStateAttacking {
		t.Errorf("Expected attacker to be attacking, got state %v", attacker.State)
	}
}

func TestCommandProcessor_GatherCommand(t *testing.T) {
	// Create test environment
	world := &World{
		Width:  100,
		Height: 100,
	}
	processor := NewCommandProcessor(world)
	objectMgr := NewObjectManager()

	// Create gatherer unit
	unit := &GameUnit{
		ID:               1,
		Position:         Vector3{X: 0, Y: 0, Z: 0},
		ResourceCarrying: make(map[string]int),
		CarryingCapacity: 50,
		GatheringSpeed:   10,
		State:           UnitStateIdle,
		CommandQueue:    make([]UnitCommand, 0),
	}

	objectMgr.AddUnit(unit)
	world.ObjectManager = objectMgr

	// Issue gather command
	gatherCmd := CreateGatherCommand(Vector3{X: 5, Y: 0, Z: 5}, "wood")
	err := processor.IssueCommand(1, gatherCmd)
	if err != nil {
		t.Fatalf("Failed to issue gather command: %v", err)
	}

	// Process command
	processor.ProcessCommands(time.Second)

	// Unit should be gathering
	if unit.State != UnitStateGathering {
		t.Errorf("Expected unit to be gathering, got state %v", unit.State)
	}
}

func TestCommandProcessor_BuildCommand(t *testing.T) {
	// Create test environment
	world := &World{
		Width:  100,
		Height: 100,
	}
	processor := NewCommandProcessor(world)
	objectMgr := NewObjectManager()

	// Create builder unit
	unit := &GameUnit{
		ID:           1,
		Position:     Vector3{X: 0, Y: 0, Z: 0},
		State:        UnitStateIdle,
		CommandQueue: make([]UnitCommand, 0),
	}

	objectMgr.AddUnit(unit)
	world.ObjectManager = objectMgr

	// Issue build command
	buildCmd := CreateBuildCommand(Vector3{X: 10, Y: 0, Z: 10}, "barracks")
	err := processor.IssueCommand(1, buildCmd)
	if err != nil {
		t.Fatalf("Failed to issue build command: %v", err)
	}

	if len(unit.CommandQueue) != 1 {
		t.Errorf("Expected 1 command in queue, got %d", len(unit.CommandQueue))
	}

	if unit.CommandQueue[0].Type != CommandBuild {
		t.Errorf("Expected Build command, got %v", unit.CommandQueue[0].Type)
	}
}

func TestCommandProcessor_StopCommand(t *testing.T) {
	// Create test environment
	world := &World{
		Width:  100,
		Height: 100,
	}
	processor := NewCommandProcessor(world)
	objectMgr := NewObjectManager()

	// Create unit with commands
	unit := &GameUnit{
		ID:           1,
		Position:     Vector3{X: 0, Y: 0, Z: 0},
		State:        UnitStateMoving,
		CommandQueue: []UnitCommand{
			CreateMoveCommand(Vector3{X: 10, Y: 0, Z: 10}),
			CreateMoveCommand(Vector3{X: 20, Y: 0, Z: 20}),
		},
	}

	objectMgr.AddUnit(unit)
	world.ObjectManager = objectMgr

	// Issue stop command
	stopCmd := CreateStopCommand()
	err := processor.IssueCommand(1, stopCmd)
	if err != nil {
		t.Fatalf("Failed to issue stop command: %v", err)
	}

	// Process command
	processor.ProcessCommands(time.Millisecond)

	// Unit should be idle and queue should be clear
	if unit.State != UnitStateIdle {
		t.Errorf("Expected unit to be idle, got state %v", unit.State)
	}

	if len(unit.CommandQueue) != 0 {
		t.Errorf("Expected command queue to be empty, got %d commands", len(unit.CommandQueue))
	}
}

func TestCommandProcessor_PatrolCommand(t *testing.T) {
	// Create test environment
	world := &World{
		Width:  100,
		Height: 100,
	}
	processor := NewCommandProcessor(world)
	objectMgr := NewObjectManager()

	// Create unit
	unit := &GameUnit{
		ID:           1,
		Position:     Vector3{X: 0, Y: 0, Z: 0},
		State:        UnitStateIdle,
		CommandQueue: make([]UnitCommand, 0),
	}

	objectMgr.AddUnit(unit)
	world.ObjectManager = objectMgr

	// Issue patrol command
	patrolCmd := CreatePatrolCommand(Vector3{X: 10, Y: 0, Z: 10})
	err := processor.IssueCommand(1, patrolCmd)
	if err != nil {
		t.Fatalf("Failed to issue patrol command: %v", err)
	}

	if len(unit.CommandQueue) != 1 {
		t.Errorf("Expected 1 command in queue, got %d", len(unit.CommandQueue))
	}

	if unit.CommandQueue[0].Type != CommandPatrol {
		t.Errorf("Expected Patrol command, got %v", unit.CommandQueue[0].Type)
	}
}

func TestCommandProcessor_ProduceCommand(t *testing.T) {
	// Create test environment
	world := &World{
		Width:  100,
		Height: 100,
	}
	processor := NewCommandProcessor(world)
	objectMgr := NewObjectManager()

	// Create building
	building := &GameBuilding{
		ID:              1,
		BuildingType:    "barracks",
		IsConstructed:   true,
		ProductionQueue: make([]ProductionItem, 0),
	}

	objectMgr.AddBuilding(building)
	world.ObjectManager = objectMgr

	// Issue produce command
	produceCmd := CreateProduceCommand("warrior")
	err := processor.IssueBuildingCommand(1, produceCmd)
	if err != nil {
		t.Fatalf("Failed to issue produce command: %v", err)
	}

	// Should add to production queue
	if len(building.ProductionQueue) != 1 {
		t.Errorf("Expected 1 item in production queue, got %d", len(building.ProductionQueue))
	}

	if building.ProductionQueue[0].UnitType != "warrior" {
		t.Errorf("Expected warrior in production queue, got %s", building.ProductionQueue[0].UnitType)
	}
}

func TestCommandProcessor_UpgradeCommand(t *testing.T) {
	// Create test environment
	world := &World{
		Width:  100,
		Height: 100,
	}
	processor := NewCommandProcessor(world)
	objectMgr := NewObjectManager()

	// Create building
	building := &GameBuilding{
		ID:            1,
		BuildingType:  "barracks",
		IsConstructed: true,
		UpgradeQueue:  make([]UpgradeItem, 0),
	}

	objectMgr.AddBuilding(building)
	world.ObjectManager = objectMgr

	// Issue upgrade command
	upgradeCmd := CreateUpgradeCommand("armor_upgrade")
	err := processor.IssueBuildingCommand(1, upgradeCmd)
	if err != nil {
		t.Fatalf("Failed to issue upgrade command: %v", err)
	}

	// Should add to upgrade queue
	if len(building.UpgradeQueue) != 1 {
		t.Errorf("Expected 1 item in upgrade queue, got %d", len(building.UpgradeQueue))
	}

	if building.UpgradeQueue[0].UpgradeType != "armor_upgrade" {
		t.Errorf("Expected armor_upgrade in queue, got %s", building.UpgradeQueue[0].UpgradeType)
	}
}

func TestCommandQueue_Priority(t *testing.T) {
	unit := &GameUnit{
		ID:           1,
		CommandQueue: make([]UnitCommand, 0),
	}

	// Add commands with different priorities
	lowCmd := CreateMoveCommand(Vector3{X: 1, Y: 0, Z: 1})
	lowCmd.Priority = PriorityLow

	normalCmd := CreateMoveCommand(Vector3{X: 2, Y: 0, Z: 2})
	normalCmd.Priority = PriorityNormal

	highCmd := CreateMoveCommand(Vector3{X: 3, Y: 0, Z: 3})
	highCmd.Priority = PriorityHigh

	criticalCmd := CreateStopCommand()
	criticalCmd.Priority = PriorityCritical

	// Add in random order
	unit.CommandQueue = append(unit.CommandQueue, lowCmd)
	unit.CommandQueue = append(unit.CommandQueue, normalCmd)
	unit.CommandQueue = append(unit.CommandQueue, highCmd)
	unit.CommandQueue = append(unit.CommandQueue, criticalCmd)

	// Sort by priority
	SortCommandsByPriority(unit.CommandQueue)

	// Should be sorted: Critical, High, Normal, Low
	expectedPriorities := []Priority{PriorityCritical, PriorityHigh, PriorityNormal, PriorityLow}
	for i, cmd := range unit.CommandQueue {
		if cmd.Priority != expectedPriorities[i] {
			t.Errorf("Command %d: expected priority %v, got %v", i, expectedPriorities[i], cmd.Priority)
		}
	}
}

func TestCommandValidation(t *testing.T) {
	// Create test environment
	world := &World{
		Width:  100,
		Height: 100,
	}
	processor := NewCommandProcessor(world)

	// Test invalid move command (out of bounds)
	moveCmd := CreateMoveCommand(Vector3{X: 200, Y: 0, Z: 200})
	if processor.IsValidCommand(moveCmd) {
		t.Error("Move command outside world bounds should be invalid")
	}

	// Test valid move command
	validMoveCmd := CreateMoveCommand(Vector3{X: 50, Y: 0, Z: 50})
	if !processor.IsValidCommand(validMoveCmd) {
		t.Error("Valid move command should be valid")
	}

	// Test attack command with invalid target
	attackCmd := CreateAttackCommand(999) // Non-existent unit
	if processor.IsValidCommand(attackCmd) {
		t.Error("Attack command with non-existent target should be invalid")
	}
}

func TestCommandProcessor_Concurrency(t *testing.T) {
	// Create test environment
	world := &World{
		Width:  100,
		Height: 100,
	}
	processor := NewCommandProcessor(world)
	objectMgr := NewObjectManager()

	// Create multiple units
	for i := 1; i <= 10; i++ {
		unit := &GameUnit{
			ID:           i,
			Position:     Vector3{X: float64(i), Y: 0, Z: 0},
			State:        UnitStateIdle,
			CommandQueue: make([]UnitCommand, 0),
		}
		objectMgr.AddUnit(unit)
	}
	world.ObjectManager = objectMgr

	// Test concurrent command issuing
	done := make(chan bool, 3)

	// Goroutine 1: Issue move commands
	go func() {
		for i := 1; i <= 10; i++ {
			cmd := CreateMoveCommand(Vector3{X: float64(i * 10), Y: 0, Z: 0})
			processor.IssueCommand(i, cmd)
		}
		done <- true
	}()

	// Goroutine 2: Issue stop commands
	go func() {
		for i := 1; i <= 10; i++ {
			cmd := CreateStopCommand()
			processor.IssueCommand(i, cmd)
		}
		done <- true
	}()

	// Goroutine 3: Process commands
	go func() {
		for i := 0; i < 50; i++ {
			processor.ProcessCommands(10 * time.Millisecond)
		}
		done <- true
	}()

	// Wait for all goroutines
	for i := 0; i < 3; i++ {
		<-done
	}

	// Verify no race conditions occurred
	units := objectMgr.GetAllUnits()
	if len(units) != 10 {
		t.Errorf("Expected 10 units, got %d", len(units))
	}
}

func TestCreateCommandHelpers(t *testing.T) {
	// Test move command creation
	moveCmd := CreateMoveCommand(Vector3{X: 10, Y: 0, Z: 15})
	if moveCmd.Type != CommandMove {
		t.Errorf("Expected Move command type, got %v", moveCmd.Type)
	}
	if moveCmd.Target.X != 10 {
		t.Errorf("Expected target X=10, got %.1f", moveCmd.Target.X)
	}

	// Test attack command creation
	attackCmd := CreateAttackCommand(5)
	if attackCmd.Type != CommandAttack {
		t.Errorf("Expected Attack command type, got %v", attackCmd.Type)
	}
	if attackCmd.TargetID != 5 {
		t.Errorf("Expected target ID 5, got %d", attackCmd.TargetID)
	}

	// Test gather command creation
	gatherCmd := CreateGatherCommand(Vector3{X: 20, Y: 0, Z: 25}, "gold")
	if gatherCmd.Type != CommandGather {
		t.Errorf("Expected Gather command type, got %v", gatherCmd.Type)
	}
	if gatherCmd.ResourceType != "gold" {
		t.Errorf("Expected resource type 'gold', got %s", gatherCmd.ResourceType)
	}

	// Test build command creation
	buildCmd := CreateBuildCommand(Vector3{X: 30, Y: 0, Z: 35}, "barracks")
	if buildCmd.Type != CommandBuild {
		t.Errorf("Expected Build command type, got %v", buildCmd.Type)
	}
	if buildCmd.BuildingType != "barracks" {
		t.Errorf("Expected building type 'barracks', got %s", buildCmd.BuildingType)
	}

	// Test stop command creation
	stopCmd := CreateStopCommand()
	if stopCmd.Type != CommandStop {
		t.Errorf("Expected Stop command type, got %v", stopCmd.Type)
	}
	if stopCmd.Priority != PriorityCritical {
		t.Errorf("Expected Critical priority for stop command, got %v", stopCmd.Priority)
	}
}

func TestCalculateDistance(t *testing.T) {
	p1 := Vector3{X: 0, Y: 0, Z: 0}
	p2 := Vector3{X: 3, Y: 0, Z: 4}

	distance := CalculateDistance(p1, p2)
	expected := 5.0 // 3-4-5 triangle

	if distance != expected {
		t.Errorf("Expected distance %.1f, got %.1f", expected, distance)
	}

	// Test same point
	distance = CalculateDistance(p1, p1)
	if distance != 0 {
		t.Errorf("Expected distance 0 for same point, got %.1f", distance)
	}
}